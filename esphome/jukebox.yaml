
esphome:
  name: rfid-jukebox
  friendly_name: RFID Jukebox Controller
  on_boot:
    priority: -10
    then:
      - delay: 1.5s            # give PN532 time to read the card
      - if:
          condition:
            lambda: 'return !id(tag_present);'
          then:
            - text_sensor.template.publish:
                id: rfid_tag_uid
                state: "none"

substitutions:
  media_player_entity_id: media_player.pau_phonie
  volume_step_small: "2"     # % per tick (slow)
  volume_step_fast: "2.5"      # % per tick (fast spin)
  accel_threshold_ms: "120"  # below this between ticks = fast

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    
logger:
  level: INFO  # set to WARN in production

api:
# encryption:
#   key: !secret api_key

ota:
  platform: esphome
#  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  reboot_timeout: 5min
  ap:
    ssid: "Jukebox Controller Fallback AP"
    password: "phoniebox"

# Optional: assign static IP for faster reconnections
#  manual_ip:
#    static_ip: 192.168.1.123
#    gateway: 192.168.1.1
#    subnet: 255.255.255.0
#    dns1: 192.168.1.1

# Consider removing in production or add auth
#web_server:
#  port: 80

#captive_portal:

i2c:
  sda: GPIO21
  scl: GPIO22
  id: i2c_bus_main

# --- Status / maintenance ---
button:
  - platform: restart
    name: "Jukebox Restart"

# If you have an LED available, uncomment and set pin
# status_led:
#   pin: GPIO2

# --- RFID: publish HA events, de-duplicate while present ---
text_sensor:
  - platform: template
    name: "RFID Jukebox Tag"
    id: rfid_tag_uid
    icon: "mdi:rfid"

globals:
  - id: last_encoder_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: current_volume_pct
    type: float
    restore_value: yes
    initial_value: '70'
  - id: tag_present
    type: bool
    restore_value: no
    initial_value: 'false'

pn532_i2c:
  i2c_id: i2c_bus_main
  update_interval: 300ms

  on_tag:
    then:
      - if:
          condition:
            lambda: 'return !id(tag_present);'
          then:
            - lambda: |-
                id(tag_present) = true;
                id(rfid_tag_uid).publish_state(x);
            - homeassistant.event:
                event: esphome.rfid_tag
                data:
                  uid: !lambda |-
                    // Make UID UPPERCASE and remove colons
                    std::string uid = x;
                    for (size_t i = 0; i < uid.size(); ++i) {
                      if (uid[i] == ':') { uid.erase(i, 1); --i; }
                      else { uid[i] = ::toupper((unsigned char)uid[i]); }
                    }
                    return uid;

  on_tag_removed:
    then:
      - if:
          condition:
            lambda: 'return id(tag_present);'
          then:
            - lambda: |-
                id(tag_present) = false;
                id(rfid_tag_uid).publish_state("none");
            - homeassistant.event:
                event: esphome.rfid_tag_removed

# --- Buttons with multi-click (less automations in HA) ---
binary_sensor:
  - platform: gpio
    name: "Jukebox Button Previous"
    pin: 
      number: GPIO18
      mode: INPUT_PULLUP
      inverted: true
    on_multi_click:
      - timing:
          - ON for at most 300ms
          - OFF for at least 50ms
        then:
          - homeassistant.action:
              action: media_player.media_previous_track
              data: 
                entity_id: ${media_player_entity_id}
      - timing:
          - ON for at least 600ms
        then:
          - homeassistant.action:
              action: media_player.media_stop
              data: 
                entity_id: ${media_player_entity_id}

  - platform: gpio
    name: "Jukebox Button Play/Pause"
    pin: { number: GPIO19, mode: INPUT_PULLUP, inverted: true }
    on_multi_click:
      - timing:
          - ON for at most 300ms
          - OFF for at least 50ms
        then:
          - homeassistant.action:
              action: media_player.media_play_pause
              data: 
                entity_id: ${media_player_entity_id} 
      - timing:
          - ON for at least 700ms
        then:
          - homeassistant.action:
              action: media_player.media_stop
              data: 
                entity_id: ${media_player_entity_id} 

  - platform: gpio
    name: "Jukebox Button Next"
    pin: { number: GPIO23, mode: INPUT_PULLUP, inverted: true }
    on_multi_click:
      - timing:
          - ON for at most 300ms
          - OFF for at least 50ms
        then:
          - homeassistant.action:
              action: media_player.media_next_track
              data: 
                entity_id: ${media_player_entity_id} 

      - timing:
          - ON for at least 600ms
        then:
          # Optional: toggle shuffle with a long-press
          - homeassistant.action:
              action: media_player.shuffle_set
              data:
                entity_id: ${media_player_entity_id}
                shuffle: "true"

  - platform: gpio
    name: "Jukebox Encoder Button"
    pin: { number: GPIO27, mode: INPUT_PULLUP, inverted: true }
    on_multi_click:
      - timing:  # short press = play/pause
          - ON for at most 300ms
          - OFF for at least 50ms
        then:
          - homeassistant.action:
              action: media_player.media_play_pause
              data: 
                entity_id: ${media_player_entity_id} 
      - timing:  # long press = mute toggle
          - ON for at least 600ms
        then:
          - homeassistant.action:
              action: media_player.volume_mute
              data:
                entity_id: ${media_player_entity_id}
                is_volume_muted: "true"

# --- Encoder with acceleration and absolute volume set ---
sensor:
  # keep your rotary encoder, but use float steps
  - platform: rotary_encoder
    name: "Jukebox Encoder Raw"
    pin_a: { number: GPIO25, inverted: true }
    pin_b: { number: GPIO26, inverted: true }
    resolution: 2
    filters:
      - throttle: 40ms
    on_clockwise:
      - lambda: |-
          const uint32_t now = millis();
          const uint32_t dt = now - id(last_encoder_ms);
          id(last_encoder_ms) = now;
          float step = (dt <= (uint32_t)(${accel_threshold_ms})) ? ${volume_step_fast} : ${volume_step_small};
          id(current_volume_pct) += step;
          if (id(current_volume_pct) > 100.0f) id(current_volume_pct) = 100.0f;
      - script.execute: set_target_volume

    on_anticlockwise:
      - lambda: |-
          const uint32_t now = millis();
          const uint32_t dt = now - id(last_encoder_ms);
          id(last_encoder_ms) = now;
          float step = (dt <= (uint32_t)(${accel_threshold_ms})) ? ${volume_step_fast} : ${volume_step_small};
          id(current_volume_pct) -= step;
          if (id(current_volume_pct) < 0.0f) id(current_volume_pct) = 0.0f;
      - script.execute: set_target_volume

  # OPTIONAL but recommended: keep your internal target synced to external changes
  - platform: homeassistant
    id: player_volume_ha
    entity_id: ${media_player_entity_id}
    attribute: volume_level
    on_value:
      then:
        - lambda: |-
            if (x >= 0.0f && x <= 1.0f) {
              id(current_volume_pct) = x * 100.0f;
            }

script:
  - id: set_target_volume
    mode: restart  # collapse bursts of encoder ticks
    then:
      - delay: 60ms
      - homeassistant.action:
          action: media_player.volume_set
          data:
            entity_id: ${media_player_entity_id}
            volume_level: !lambda "return id(current_volume_pct) / 100.0f;"

